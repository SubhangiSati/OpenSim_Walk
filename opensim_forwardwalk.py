# -*- coding: utf-8 -*-
"""Opensim_forwardwalk.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1blSIa9MWDrLwMtFwXLEVAGfbGIaXKoVh

STEP 1: INSTALL CONDA TO WORK ON OPEN SIM IN GOOGLE COLAB
"""

#!conda --version
#If !conda --version returns no results, install conda with uncommenting the next three lines:
!pip install -q condacolab
import condacolab
condacolab.install()
!conda install -c opensim-org opensim

"""STEP 2: INSTALL NECESSARY LIBRARIES"""

import time
start_time = time.time()
!pip uninstall -y -q plotly;
!pip install -q plotly
!pip uninstall -y -q pandas;
!pip install -q pandas
import pandas as pd
import plotly
pd.set_option('plotting.backend','plotly')
def enable_plotly_in_cell():
    import IPython
    from plotly.offline import init_notebook_mode
    display(IPython.core.display.HTML('''<script src="/static/components/requirejs/require.js"></script>'''))
    init_notebook_mode(connected=False)

get_ipython().events.register('pre_run_cell', enable_plotly_in_cell)
# !wget -c https://repo.anaconda.com/miniconda/Miniconda3-py37_4.8.3-Linux-x86_64.sh
# !chmod +x Miniconda3-py37_4.8.3-Linux-x86_64.sh
# !bash ./Miniconda3-py37_4.8.3-Linux-x86_64.sh -b -f -p /usr/local
# import sys
# sys.path.append('/usr/local/lib/python3.7/site-packages')
# # !conda install -y --prefix /usr/local -c ember123 opencolab
# !conda install -y --prefix /usr/local -c opensim-org opensim
!apt-get update -y
!apt-get install -y x11-apps
!apt install mesa-utils
!apt-get install xvfb x11-utils
!pip install pyvirtualdisplay
from pyvirtualdisplay import Display
Display(visible=0, size=(1400, 900)).start()
!pip install c3d
!pip install numpy --upgrade
!pip install -q --upgrade ipython
!pip install -q --upgrade ipykernel
!pip install tensorflow==2.0.0.alpha0
!conda install -c plotly -y plotly-orca
!pip install svgutils
!apt install libadolc2
!apt-get install coinor-libipopt-dev
# import opensim as osim
# print('OpenSim Version Installed is version:',osim.__version__)
print(f'The execution time of OpenSim Package Installation is {(time.time() - start_time)} sec')
import opensim as osim
print('OpenSim Version Installed is version:',osim.__version__)

"""STEP 3: IMPORT ALL THE DATASETS REQUIRED"""

!git clone https://github.com/opensim-org/opensim-models.git # models needed
!git clone https://github.com/HernandezVincent/OpenSim.git  # models needed
!cp /content/opensim-models/Models/Gait2354_Simbody/* /content/opensim-models/Pipelines/Gait2354_Simbody
!git clone https://github.com/ESJiang/2354_xml.git
!cp -rf /content/2354_xml/* /content/opensim-models/Pipelines/Gait2354_Simbody
!git clone https://github.com/ESJiang/2354_result.git
!git clone https://github.com/ESJiang/testc3d.git

"""STEP 4: CHECK NECESSARY FUNCTION REQUIRED FOR PLOTTING"""

from linecache import getline
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from matplotlib import pyplot
import numpy as np
import cv2

def find_nearest_element(time, start, end):
    print(min(time, key=lambda x: abs(x-Decimal(start))))
    print(time.index(min(time, key=lambda x: abs(x-Decimal(start)))))
    print(min(time, key=lambda x: abs(x-Decimal(end))))
    print(time.index(min(time, key=lambda x: abs(x-Decimal(end)))))
    print((min(time, key=lambda x: abs(x-Decimal(1.840)))+min(time, key=lambda x: abs(x-Decimal(0.600))))/2)
    print(time.index(min(time, key=lambda x: abs(x-(min(time, key=lambda x: abs(x-Decimal(end)))+min(time, key=lambda x: abs(x-Decimal(start))))/2))))

def judge_line_number(path):
    count = 1
    f = open(path,"r")
    line = f.readline()
    while line!="":
        s=line[:4]
        if s.upper()=="time".upper():
          return count
        else:
          count = count + 1
          line = f.readline()

def generate_dict(path):
    def sto_Getline(path):
      return getline(path, judge_line_number(path)).strip('\n').split()
    for each in dict(zip(sto_Getline(path), range(0,len(sto_Getline(path))))):
      print(each, ':', dict(zip(sto_Getline(path), range(0,len(sto_Getline(path)))))[each])

def three(fig, y1, y1_name, y2, y2_name, y3, y3_name, title):
    fig.add_trace(go.Scatter(x=time_5, y=y1, name=y1_name, mode="lines",
                         line=dict(color='red', width=0.5, dash='solid')))
    fig.add_trace(go.Scatter(x=time_10, y=y2, name=y2_name, mode="lines",
                         line=dict(color='blue', width=0.5, dash='solid')))
    fig.add_trace(go.Scatter(x=time_20, y=y3, name=y3_name, mode="lines",
                         line=dict(color='green', width=0.5, dash='solid')))
    fig.update_layout(title='<b>'+title+'<b>', xaxis_title='time', yaxis_title='value',font=dict(
        family="Courier New, monospace",
        size=24,
        #color="RebeccaPurple"
    ))
    fig.show()

def four(fig, x, y1, y1_name, y2, y2_name, y3, y3_name, y4, y4_name, title, fig_name):
    fig.add_trace(go.Scatter(x=x, y=y1, name=y1_name, mode="lines",
                         line=dict(color='black', width=2, dash='solid')))
    fig.add_trace(go.Scatter(x=x, y=y2, name=y2_name, mode="lines",
                         line=dict(color='grey', width=2, dash='solid')))
    fig.add_trace(go.Scatter(x=x, y=y3, name=y3_name, mode="lines",
                         line=dict(color='black', width=2, dash='dash')))
    fig.add_trace(go.Scatter(x=x, y=y4, name=y4_name, mode="lines",
                         line = dict(color='grey', width=2, dash='dash')))
    fig.update_layout(title={
    'text': '<b>'+title+'<b>',
    'y': 0.9,
    'x': 0.5,
    'xanchor': 'center',
    'yanchor': 'top'}, xaxis_title='time', yaxis_title='value',font=dict(
        family="Courier New, monospace",
        size=24), template="simple_white"
        )

r_FO = 1.43 #@param {type:"number"}

def four_IDTool(fig, x, y1, y1_name, y2, y2_name, y3, y3_name, y4, y4_name, title, fig_name):
    fig.add_trace(go.Scatter(x=x, y=y1, name=y1_name, mode="lines",
                         line=dict(color='black', width=2, dash='solid')))
    fig.add_trace(go.Scatter(x=x, y=y2, name=y2_name, mode="lines",
                         line=dict(color='grey', width=2, dash='solid')))
    fig.add_trace(go.Scatter(x=x, y=y3, name=y3_name, mode="lines",
                         line=dict(color='black', width=2, dash='dash')))
    fig.add_trace(go.Scatter(x=x, y=y4, name=y4_name, mode="lines",
                         line = dict(color='grey', width=2, dash='dash')))
    fig.add_vline(x=r_FO, annotation_position="top",annotation_text="r_FO", line_width=2, line_dash="dash", line_color="red")
    #fig.add_vline(x=0.308, annotation_position="bottom",annotation_text="l_FO", line_width=1, line_dash="dash", line_color="blue")
    #fig.add_vline(x=0.888, annotation_position="top",annotation_text="l-FS", line_width=1, line_dash="dash", line_color="red")
    #fig.add_vline(x=0.918, annotation_position="bottom",annotation_text="r_FO", line_width=1, line_dash="dash", line_color="blue")
    fig.update_layout(title={
    'text': '<b>'+title+'<b>',
    'y': 0.95,
    'x': 0.5,
    'xanchor': 'center',
    'yanchor': 'top'}, yaxis_title='value',font=dict(
        family="Courier New, monospace",
        size=24), template="simple_white"
        )

def six(fig, x, y1, y1_name, y2, y2_name, y3, y3_name, y4, y4_name, y5, y5_name, y6, y6_name, title, fig_name):
    fig.add_trace(go.Scatter(x=x, y=y1, name=y1_name, mode="lines",
                            line=dict(color='black', width=2, dash='solid')))
    fig.add_trace(go.Scatter(x=x, y=y2, name=y2_name, mode="lines",
                            line=dict(color='grey', width=2, dash='solid')))
    fig.add_trace(go.Scatter(x=x, y=y3, name=y3_name, mode="lines",
                            line=dict(color='black', width=2, dash='solid')))
    fig.add_trace(go.Scatter(x=x, y=y4, name=y4_name, mode="lines",
                            line = dict(color='grey', width=2, dash='solid')))
    fig.add_trace(go.Scatter(x=x, y=y5, name=y5_name, mode="lines",
                            line=dict(color='black', width=2, dash='solid')))
    fig.add_trace(go.Scatter(x=x, y=y6, name=y6_name, mode="lines",
                            line = dict(color='grey', width=2, dash='solid')))
    fig.update_layout(title='<b>'+title+'<b>', xaxis_title='time', yaxis_title='value',font=dict(
        family="Courier New, monospace",
        size=24,
        #color="RebeccaPurple"
    ))
    fig.show()
    fig.write_image(fig_name)

print('finished')

"""FOR 3-D BIOMECHANICS (OPTIONAL)"""

from c3d import Reader
r = Reader(open('/content/testc3d/walking5.c3d', 'rb'))
for frame_no, points, analog in r.read_frames():
    print('{0.shape} points in this frame'.format(points))

"""CODE FOR INVERSE KINEMATICS (WALKING AT SINGLE PLACE)"""

from opensim import ScaleTool
import time
start_time = time.time()
ScaleTool("/content/opensim-models/Pipelines/Gait2354_Simbody/subject01_Setup_Scale.xml").run()
print(f'The execution time of ScaleTool is {(time.time() - start_time)} sec')

#You can compare these values below and the ones from GUI above.
import os
if os.path.exists('/content/opensim-models/Pipelines/Gait2354_Simbody/opensim.log'):
    with open('/content/opensim-models/Pipelines/Gait2354_Simbody/opensim.log','r') as f:
        print([line for line in f if 'Frame at (t = 1.0):	 total squared error = ' in line])

from opensim import InverseKinematicsTool
import time
start_time = time.time()
InverseKinematicsTool("/content/opensim-models/Pipelines/Gait2354_Simbody/subject01_Setup_IK.xml").run()
print(f'The execution time of InverseKinematicsTool is {(time.time() - start_time)} sec')

generate_dict("/content/opensim-models/Pipelines/Gait2354_Simbody/subject01_walk1_ik.mot")

from decimal import Decimal
time, ankle_angle_r, ankle_angle_l, knee_angle_r,knee_angle_l= [],[],[],[],[]
hip_flexion_r, hip_flexion_l=[],[]
def load_file_1(file_name):
    c = open(file_name)
    for x in range(judge_line_number(file_name)):
        next(c)
    for i in c.readlines():
        m = i.strip('\n').split()
        time.append(Decimal(m[0]))
        ankle_angle_r.append(Decimal(m[11]))
        ankle_angle_l.append(Decimal(m[18]))
        knee_angle_r.append(Decimal(m[10]))
        knee_angle_l.append(Decimal(m[17]))
        hip_flexion_r.append(Decimal(m[7]))
        hip_flexion_l.append(Decimal(m[14]))
    c.flush()
    c.close()
load_file_1("/content/opensim-models/Pipelines/Gait2354_Simbody/subject01_walk1_ik.mot")

from decimal import Decimal
time1, ankle_angle_r1, ankle_angle_l1, knee_angle_r1,knee_angle_l1= [],[],[],[],[]
hip_flexion_r1, hip_flexion_l1 = [],[]
def load_file_1(file_name):
    c = open(file_name)
    for x in range(judge_line_number(file_name)):
        next(c)
    for i in c.readlines():
        m = i.strip('\n').split()
        time1.append(Decimal(m[0]))
        ankle_angle_r1.append(Decimal(m[11]))
        ankle_angle_l1.append(Decimal(m[18]))
        knee_angle_r1.append(Decimal(m[10]))
        knee_angle_l1.append(Decimal(m[17]))
        hip_flexion_r1.append(Decimal(m[7]))
        hip_flexion_l1.append(Decimal(m[14]))
    c.flush()
    c.close()
load_file_1("/content/2354_result/subject01_walk1_ik.mot")

df1 = pd.DataFrame({'ankle_angle_r_Colab': ankle_angle_r, 'ankle_angle_l_Colab': ankle_angle_l, 'ankle_angle_r_GUI': ankle_angle_r1, 'ankle_angle_l_GUI': ankle_angle_l1}, index = time)
df2 = pd.DataFrame({'knee_angle_r_Colab': knee_angle_r, 'knee_angle_l_Colab': knee_angle_l, 'knee_angle_r_GUI': knee_angle_r1, 'knee_angle_l_GUI': knee_angle_l1}, index = time)
df3 = pd.DataFrame({'hip_flexion_r_Colab': hip_flexion_r, 'hip_flexion_l_Colab': hip_flexion_l, 'hip_flexion_r_GUI': hip_flexion_r1, 'hip_flexion_l_GUI': hip_flexion_l1}, index = time)
df1.index.name = df2.index.name = df3.index.name = 'time'
df1.plot(title='<b>ankle_angle_IK<b>').show()
df2.plot(title='<b>knee_angle_IK<b>').show()
df3.plot(title='<b>hip_flexion_IK<b>').show()

import opensim
import time

# Load the model
model_path = "/content/opensim-models/Pipelines/Gait2354_Simbody/subject01_Setup_Forward.xml"
model = opensim.Model(model_path)

# Create a forward tool
forward_tool = opensim.ForwardTool()

# Set the tool's attributes
forward_tool.setModel(model)
forward_tool.setStartTime(0)
forward_tool.setFinalTime(1)  # Adjust this according to your simulation duration
forward_tool.setSolveForEquilibrium(True)
forward_tool.setInitialTime(0)

# Set the output directory
output_dir = "/content/forward_simulation_output"
forward_tool.setOutputDirectory(output_dir)

# Run the forward dynamics simulation
start_time = time.time()
forward_tool.run()
print(f'The execution time of Forward Dynamics Simulation is {(time.time() - start_time)} sec')

import opensim
import time
try:
    model_path = "/content/opensim-models/Pipelines/Gait2354_Simbody/subject01_Setup_Forward.xml"
    model = opensim.Model(model_path)
    print("Model loaded successfully.")
except RuntimeError as e:
    print("Error loading model:", e)

# Create a forward tool
forward_tool = opensim.ForwardTool()

# Set the tool's attributes
forward_tool.setModel(model)
forward_tool.setStartTime(0)
forward_tool.setEndTime(1)  # Adjust this according to your simulation duration
forward_tool.setSolveForEquilibrium(True)
forward_tool.setInitialTime(0)
forward_tool.setFinalTime(1)  # Adjust this according to your simulation duration

# Set the output directory
output_dir = "/content/forward_simulation_output"
forward_tool.setOutputDirectory(output_dir)

# Run the forward dynamics simulation
start_time = time.time()
forward_tool.run()
print(f'The execution time of Forward Dynamics Simulation is {(time.time() - start_time)} sec')

# Generate video
visualizer = opensim.ModelVisualizer(model)
states_table = opensim.TimeSeriesTable(os.path.join(output_dir, "states.sto"))
visualizer.setStates(states_table)
visualizer.setDesiredSimTKVisualizer("osim")
visualizer.setCameraPosition([1, 1, 1], [0, 0, 0], [0, 1, 0])
visualizer.setShowFrameNumber(True)
visualizer.setShowTime(True)
visualizer.setGroundHeight(0)

video_file = os.path.join(output_dir, "animation.mp4")
visualizer.setPlaybackSpeed(1.0)
visualizer.setOpenSimLiveMode(True)
visualizer.setWriteToAVIFile(True)
visualizer.setAVIFileName(video_file)
visualizer.setWriteToMP4File(True)
visualizer.setMP4FileName(video_file)

# Set up the hand motion
# Modify the model to include hand motion according to your requirements

# Run the visualizer
visualizer.updateModel(model)
visualizer.updateVisualizer()
visualizer.setSimTKVisualizerFrameRate(60)
visualizer.showConfiguration()

# Save the video
visualizer.saveMP4()

print("Video saved successfully!")

import opensim
import numpy as np
from opensim import Model

# Load the example gait2392 model included with OpenSim
model = Model("/content/opensim-models/Pipelines/Gait2354_Simbody/gait2354_simbody.osim")


# Create a neural controller (placeholder)
class NeuralController:
    def __init__(self, model):
        self.model = model
        self.muscles = model.getMuscles()

    def update(self, time):
        # Calculate muscle activations based on neural signals
        activations = np.zeros(self.muscles.getSize())
        # Example: Activate leg muscles for walking
        for muscle in self.muscles:
            if 'leg' in muscle.getName().lower():
                activations[muscle.getIndex()] = 0.5
        # Example: Activate arm muscles for arm movement
        # Adjust the condition and activation level based on your specific requirements
        for muscle in self.muscles:
            if 'arm' in muscle.getName().lower():
                activations[muscle.getIndex()] = 0.3  # Adjust activation level as needed
        return activations

# Create neural controller instance
controller = NeuralController(model)

# Set up simulation
state = model.initSystem()
simulator = opensim.Manager(model)
simulator.initialize(state)

# Simulate movement for 10 seconds
total_duration = 10.0  # seconds
time_step = 0.01  # seconds
num_steps = int(total_duration / time_step)

# OpenSim stores motion data in Storage objects
arm_moments = opensim.Storage()

for i in range(num_steps):
    time = i * time_step
    activations = controller.update(time)
    model.getControls(state).set(activations)
    state = simulator.integrate(time)

    # Save arm moment data
    arm_moments.append(time, [model.getCoordinateSet().get('shoulder_flexion').getControl(state)])

# Save arm moment data to file
arm_moments.printToFile("arm_moments.sto")

print("Simulation completed.")

pip install opensim